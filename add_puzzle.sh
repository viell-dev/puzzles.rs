#!/usr/bin/env bash

# Scaffolding script generated by Claude Sonnet 4.5
# I have no idea how bash works...
# But this does the job I needed it to.

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print error messages
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

# Function to print success messages
success() {
    echo -e "${GREEN}$1${NC}"
}

# Function to print info messages
info() {
    echo -e "${YELLOW}$1${NC}"
}

# Validate arguments
if [ $# -ne 2 ]; then
    error "Usage: $0 <path> <name>\n  Example: $0 advent_of_code/2025/day01 aoc_2025_day01"
fi

PUZZLE_PATH="$1"
PUZZLE_NAME="$2"
FULL_PATH="puzzles/$PUZZLE_PATH"

# Check if puzzle already exists
if [ -d "$FULL_PATH" ]; then
    error "Puzzle directory already exists: $FULL_PATH"
fi

# Calculate the depth (number of directory levels) to determine relative path
IFS='/' read -ra PATH_PARTS <<< "$PUZZLE_PATH"
DEPTH=${#PATH_PARTS[@]}
RELATIVE_PATH=""
for ((i=0; i<DEPTH; i++)); do
    RELATIVE_PATH="../$RELATIVE_PATH"
done
RELATIVE_PATH="${RELATIVE_PATH}../lib/input_reader"

info "Creating puzzle at: $FULL_PATH"
info "Package name: $PUZZLE_NAME"
info "Input reader path: $RELATIVE_PATH"

# Create directory structure
mkdir -p "$FULL_PATH/src"

# Create Cargo.toml
cat > "$FULL_PATH/Cargo.toml" <<EOF
[package]
name = "$PUZZLE_NAME"
version.workspace = true
edition.workspace = true
license.workspace = true

[lints]
workspace = true

[dependencies]
input_reader = { path = "$RELATIVE_PATH" }
derive_more = { version = "2", features = ["full"] }
EOF

success "Created: $FULL_PATH/Cargo.toml"

# Create src/main.rs based on puzzle type
if [[ "$PUZZLE_PATH" == advent_of_code/* ]]; then
    # Advent of Code template with part1 and part2
    cat > "$FULL_PATH/src/main.rs" <<'EOF'
use input_reader::{Input, Outcome, read_input};

fn main() {
    let input = match read_input().expect("failed to read input") {
        Outcome::Exit => return,
        Outcome::Continue(input) => input,
    };

    let parsed = parse_input(input);

    let part1 = solve_part1(parsed.clone());
    println!("Part 1 solution: {part1}");

    let part2 = solve_part2(parsed);
    println!("Part 2 solution: {part2}");
}

// -----------------------------------------------------------------------------
// Input Parsing
// -----------------------------------------------------------------------------

fn parse_input(input: Input) -> () {
    todo!();
}

// -----------------------------------------------------------------------------
// Solutions
// -----------------------------------------------------------------------------

fn solve_part1(parsed: ()) -> () {
    todo!();
}

fn solve_part2(parsed: ()) -> () {
    todo!();
}

// -----------------------------------------------------------------------------
// Internals
// -----------------------------------------------------------------------------



// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;

    struct TestData {
        input: Input,
        parsed: (),
        part1: (),
        part2: (),
    }

    fn get_test_data() -> Vec<TestData> {
        vec![
            // TestData {
            //     input: Input::from("example"),
            //     parsed: todo!(),
            //     part1: todo!(),
            //     part2: todo!(),
            // },
        ]
    }

    #[test]
    fn test_parse_input() {
        for data in get_test_data() {
            assert_eq!(parse_input(data.input), data.parsed);
        }
    }

    #[test]
    fn test_solve_part1() {
        for data in get_test_data() {
            assert_eq!(solve_part1(data.parsed), data.part1);
        }
    }

    #[test]
    fn test_solve_part2() {
        for data in get_test_data() {
            assert_eq!(solve_part2(data.parsed), data.part2);
        }
    }
}

EOF
else
    # Standard template with single solve function
    cat > "$FULL_PATH/src/main.rs" <<'EOF'
use input_reader::{Input, Outcome, read_input};

fn main() {
    let input = match read_input().expect("failed to read input") {
        Outcome::Exit => return,
        Outcome::Continue(input) => input,
    };

    let parsed = parse_input(input);

    let solution = solve(parsed);
    println!("Solution: {solution}");
}

// -----------------------------------------------------------------------------
// Input Parsing
// -----------------------------------------------------------------------------

fn parse_input(input: Input) -> () {
    todo!();
}

// -----------------------------------------------------------------------------
// Solutions
// -----------------------------------------------------------------------------

fn solve(parsed: ()) -> () {
    todo!();
}

// -----------------------------------------------------------------------------
// Internals
// -----------------------------------------------------------------------------



// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;

    struct TestData {
        input: Input,
        parsed: (),
        solution: (),
    }

    fn get_test_data() -> Vec<TestData> {
        vec![
            // TestData {
            //     input: Input::from("example"),
            //     parsed: todo!(),
            //     solution: todo!(),
            // },
        ]
    }

    #[test]
    fn test_parse_input() {
        for data in get_test_data() {
            assert_eq!(parse_input(data.input), data.parsed);
        }
    }

    #[test]
    fn test_solve() {
        for data in get_test_data() {
            assert_eq!(solve(data.parsed), data.solution);
        }
    }
}

EOF
fi

success "Created: $FULL_PATH/src/main.rs"

# Update workspace Cargo.toml
WORKSPACE_TOML="Cargo.toml"
PARENT_PATH="${PUZZLE_PATH%/*}"
WORKSPACE_PATTERN="puzzles/$PARENT_PATH/*"

# Extract first directory component (e.g., "advent_of_code" from "advent_of_code/2015/day02")
FIRST_DIR="${PUZZLE_PATH%%/*}"

info "Checking workspace members in $WORKSPACE_TOML"

# Check if any broader pattern already covers this puzzle
# Look for patterns like "puzzles/advent_of_code/*" or "puzzles/advent_of_code/20??/day??"
if grep -E "\"puzzles/$FIRST_DIR/[^\"]*[\*\?]" "$WORKSPACE_TOML" > /dev/null; then
    EXISTING_PATTERN=$(grep -oE "\"puzzles/$FIRST_DIR/[^\"]*[\*\?][^\"]*\"" "$WORKSPACE_TOML" | head -1 | tr -d '"')
    info "Workspace already covered by existing pattern: $EXISTING_PATTERN"
elif grep -q "\"$WORKSPACE_PATTERN\"" "$WORKSPACE_TOML"; then
    info "Workspace pattern already exists: $WORKSPACE_PATTERN"
else
    info "Adding workspace pattern: $WORKSPACE_PATTERN"

    # Find the members line and add the new pattern
    # This uses sed to find the members array and add the new pattern
    if grep -q "^members = \[.*\]$" "$WORKSPACE_TOML"; then
        # Members array is on a single line
        sed -i "s|^members = \[\(.*\)\]|members = [\1, \"$WORKSPACE_PATTERN\"]|" "$WORKSPACE_TOML"
    else
        # Members array spans multiple lines - add before the closing bracket
        sed -i "/^members = \[/,/^\s*\]/{ /^\s*\]/i\\    \"$WORKSPACE_PATTERN\",
        }" "$WORKSPACE_TOML"
    fi

    success "Added to workspace: $WORKSPACE_PATTERN"
fi

echo ""
success "Puzzle scaffolded successfully!"
info "Next steps:"
echo "  1. cd $FULL_PATH"
echo "  2. Implement your solution in src/main.rs"
echo "  3. Run with: cargo run"
