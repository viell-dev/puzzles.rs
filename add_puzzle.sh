#!/usr/bin/env bash

# Scaffolding script generated by Claude Sonnet 4.5
# I have no idea how bash works...
# But this does the job I needed it to.

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print error messages
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

# Function to print success messages
success() {
    echo -e "${GREEN}$1${NC}"
}

# Function to print info messages
info() {
    echo -e "${YELLOW}$1${NC}"
}

# Validate arguments
if [ $# -ne 2 ]; then
    error "Usage: $0 <path> <name>\n  Example: $0 advent_of_code/2025/day01 aoc_2025_day01"
fi

PUZZLE_PATH="$1"
PUZZLE_NAME="$2"
FULL_PATH="puzzles/$PUZZLE_PATH"

# Check if puzzle already exists
if [ -d "$FULL_PATH" ]; then
    error "Puzzle directory already exists: $FULL_PATH"
fi

# Calculate the depth (number of directory levels) to determine relative path
IFS='/' read -ra PATH_PARTS <<< "$PUZZLE_PATH"
DEPTH=${#PATH_PARTS[@]}
RELATIVE_PATH=""
for ((i=0; i<DEPTH; i++)); do
    RELATIVE_PATH="../$RELATIVE_PATH"
done
RELATIVE_PATH="${RELATIVE_PATH}../lib/input_reader"

info "Creating puzzle at: $FULL_PATH"
info "Package name: $PUZZLE_NAME"
info "Input reader path: $RELATIVE_PATH"

# Create directory structure
mkdir -p "$FULL_PATH/src"

# Create Cargo.toml
cat > "$FULL_PATH/Cargo.toml" <<EOF
[package]
name = "$PUZZLE_NAME"
version.workspace = true
edition.workspace = true
license.workspace = true

[lints]
workspace = true

[dependencies]
input_reader = { path = "$RELATIVE_PATH" }
derive_more = { version = "2", features = ["full"] }
EOF

success "Created: $FULL_PATH/Cargo.toml"

# Create src/main.rs based on puzzle type
if [[ "$PUZZLE_PATH" == advent_of_code/* ]]; then
    # Advent of Code template with part1 and part2
    cat > "$FULL_PATH/src/main.rs" <<'EOF'
use input_reader::{Input, Outcome, read_input};

fn main() {
    let input = match read_input().expect("failed to read input") {
        Outcome::Exit => return,
        Outcome::Continue(input) => input,
    };

    let _rename_me = parse_input(input);

    solve_part1(_rename_me.clone());
    solve_part2(_rename_me);
}

// -----------------------------------------------------------------------------
// Input Parsing
// -----------------------------------------------------------------------------

fn parse_input(input: Input) -> () {
    todo!();
}

// -----------------------------------------------------------------------------
// Solutions
// -----------------------------------------------------------------------------

fn solve_part1(_rename_me: ()) {
    todo!();
}

fn solve_part2(_rename_me: ()) {
    todo!();
}

// -----------------------------------------------------------------------------
// Internals
// -----------------------------------------------------------------------------

EOF
else
    # Standard template with single solve function
    cat > "$FULL_PATH/src/main.rs" <<'EOF'
use input_reader::{Input, Outcome, read_input};

fn main() {
    let input = match read_input().expect("failed to read input") {
        Outcome::Exit => return,
        Outcome::Continue(input) => input,
    };

    let _rename_me = parse_input(input);

    solve(_rename_me);
}

// -----------------------------------------------------------------------------
// Input Parsing
// -----------------------------------------------------------------------------

fn parse_input(input: Input) -> () {
    todo!();
}

// -----------------------------------------------------------------------------
// Solutions
// -----------------------------------------------------------------------------

fn solve(_rename_me: ()) {
    todo!();
}

// -----------------------------------------------------------------------------
// Internals
// -----------------------------------------------------------------------------

EOF
fi

success "Created: $FULL_PATH/src/main.rs"

# Update workspace Cargo.toml
WORKSPACE_TOML="Cargo.toml"
PARENT_PATH="${PUZZLE_PATH%/*}"
WORKSPACE_PATTERN="puzzles/$PARENT_PATH/*"

# Extract first directory component (e.g., "advent_of_code" from "advent_of_code/2015/day02")
FIRST_DIR="${PUZZLE_PATH%%/*}"

info "Checking workspace members in $WORKSPACE_TOML"

# Check if any broader pattern already covers this puzzle
# Look for patterns like "puzzles/advent_of_code/*" or "puzzles/advent_of_code/20??/day??"
if grep -E "\"puzzles/$FIRST_DIR/[^\"]*[\*\?]" "$WORKSPACE_TOML" > /dev/null; then
    EXISTING_PATTERN=$(grep -oE "\"puzzles/$FIRST_DIR/[^\"]*[\*\?][^\"]*\"" "$WORKSPACE_TOML" | head -1 | tr -d '"')
    info "Workspace already covered by existing pattern: $EXISTING_PATTERN"
elif grep -q "\"$WORKSPACE_PATTERN\"" "$WORKSPACE_TOML"; then
    info "Workspace pattern already exists: $WORKSPACE_PATTERN"
else
    info "Adding workspace pattern: $WORKSPACE_PATTERN"

    # Find the members line and add the new pattern
    # This uses sed to find the members array and add the new pattern
    if grep -q "^members = \[.*\]$" "$WORKSPACE_TOML"; then
        # Members array is on a single line
        sed -i "s|^members = \[\(.*\)\]|members = [\1, \"$WORKSPACE_PATTERN\"]|" "$WORKSPACE_TOML"
    else
        # Members array spans multiple lines - add before the closing bracket
        sed -i "/^members = \[/,/^\s*\]/{ /^\s*\]/i\\    \"$WORKSPACE_PATTERN\",
        }" "$WORKSPACE_TOML"
    fi

    success "Added to workspace: $WORKSPACE_PATTERN"
fi

echo ""
success "Puzzle scaffolded successfully!"
info "Next steps:"
echo "  1. cd $FULL_PATH"
echo "  2. Implement your solution in src/main.rs"
echo "  3. Run with: cargo run"
